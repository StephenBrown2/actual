name: Count points

on:
  schedule:
    # Run at 00:00 on the first day of every month
    - cron: '0 0 1 * *'
  workflow_dispatch:
    inputs:
      startDate:
        description: 'Start date for point counter (YYYY-MM-DD)'
        required: true
        type: string

jobs:
  count-points:
    runs-on: ubuntu-latest
    steps:
      - name: Count points
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          START_DATE: ${{ inputs.startDate }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const CONFIG = {
              POINTS_PER_ISSUE_TRIAGE_ACTION: 1,
              POINTS_PER_ISSUE_CLOSING_ACTION: 1,
              POINTS_PER_RELEASE_PR: 4,
              CODE_PR_REVIEW_POINT_TIERS: [
                { minChanges: 500, points: 8 },
                { minChanges: 100, points: 6 },
                { minChanges: 10, points: 2 },
                { minChanges: 0, points: 1 },
              ],
              DOCS_PR_REVIEW_POINT_TIERS: [
                { minChanges: 2000, points: 6 },
                { minChanges: 200, points: 4 },
                { minChanges: 0, points: 2 },
              ],
              EXCLUDED_FILES: [
                'yarn.lock',
                '.yarn/**/*',
                'packages/component-library/src/icons/**/*',
                'release-notes/**/*',
                'upcoming-release-notes/**/*',
              ],
              DOCS_FILES_PATTERN: 'packages/docs/**/*',
            };

            function getLastMonthDates() {
              const now = new Date();
              const firstDayOfLastMonth = new Date(
                Date.UTC(
                  now.getUTCFullYear(),
                  now.getUTCMonth() - 1,
                  1,
                  0,
                  0,
                  0,
                  0,
                ),
              );
              const since = process.env.START_DATE
                ? new Date(Date.parse(process.env.START_DATE))
                : firstDayOfLastMonth;
              const until = new Date(
                Date.UTC(
                  since.getUTCFullYear(),
                  since.getUTCMonth() + 1,
                  0,
                  23,
                  59,
                  59,
                  999,
                ),
              );
              return { since, until };
            }

            function matchesPattern(fileName, pattern) {
              if (pattern.endsWith('/**/*')) {
                return fileName.startsWith(pattern.slice(0, -4));
              }
              return fileName === pattern;
            }

            function isExcludedFile(fileName) {
              return CONFIG.EXCLUDED_FILES.some(pattern =>
                matchesPattern(fileName, pattern),
              );
            }

            function isDocsFile(fileName) {
              return matchesPattern(fileName, CONFIG.DOCS_FILES_PATTERN);
            }

            async function withConcurrency(items, limit, worker) {
              let index = 0;
              const workers = new Array(Math.min(limit, items.length))
                .fill(0)
                .map(async () => {
                  while (index < items.length) {
                    const currentIndex = index;
                    index += 1;
                    await worker(items[currentIndex], currentIndex);
                  }
                });
              await Promise.all(workers);
            }

            async function countContributorPoints() {
              const owner = 'actualbudget';
              const repo = 'actual';

              const { since, until } = getLastMonthDates();

              const orgMembers = await github.paginate(
                github.rest.orgs.listMembers,
                {
                  org: owner,
                  per_page: 100,
                },
              );
              const orgMemberLogins = new Set(
                orgMembers.map(member => member.login),
              );

              const stats = new Map(
                Array.from(orgMemberLogins).map(login => [
                  login,
                  {
                    codeReviews: [],
                    docsReviews: [],
                    labelRemovals: [],
                    issueClosings: [],
                    points: 0,
                  },
                ]),
              );

              const printStats = (title, getValue, formatLine) => {
                console.log(`\n${title}:`);
                console.log('='.repeat(title.length + 1));

                const entries = Array.from(stats.entries())
                  .map(([user, userStats]) => [user, getValue(userStats)])
                  .filter(([, count]) => count > 0)
                  .sort((a, b) => b[1] - a[1]);

                if (entries.length === 0) {
                  console.log(`No ${title.toLowerCase()} found in the last month.`);
                } else {
                  entries.forEach(([user, count]) => {
                    console.log(formatLine(user, count));
                  });
                }
              };

              const searchQuery = `repo:${owner}/${repo} is:pr is:merged merged:${since.toISOString()}..${until.toISOString()}`;
              const recentPRs = await github.paginate(
                'GET /search/issues',
                {
                  q: searchQuery,
                  per_page: 100,
                  advanced_search: true,
                },
                response => response.data.filter(pr => pr.number),
              );

              await withConcurrency(recentPRs, 50, async pr => {
                const [reviews, modifiedFiles] = await Promise.all([
                  github.rest.pulls.listReviews({
                    owner,
                    repo,
                    pull_number: pr.number,
                  }),
                  github.paginate(
                    github.rest.pulls.listFiles,
                    {
                      owner,
                      repo,
                      pull_number: pr.number,
                      per_page: 100,
                    },
                    res => res.data,
                  ),
                ]);

                const filteredFiles = modifiedFiles.filter(
                  file => !isExcludedFile(file.filename),
                );
                const docsFiles = filteredFiles.filter(file =>
                  isDocsFile(file.filename),
                );
                const codeFiles = filteredFiles.filter(
                  file => !isDocsFile(file.filename),
                );

                const docsChanges = docsFiles.reduce(
                  (sum, file) => sum + file.additions + file.deletions,
                  0,
                );
                const codeChanges = codeFiles.reduce(
                  (sum, file) => sum + file.additions + file.deletions,
                  0,
                );

                const docsPoints =
                  docsChanges > 0
                    ? (CONFIG.DOCS_PR_REVIEW_POINT_TIERS.find(
                        tier => docsChanges >= tier.minChanges,
                      )?.points ?? 0)
                    : 0;
                const codePoints =
                  codeChanges > 0 || docsChanges === 0
                    ? (CONFIG.CODE_PR_REVIEW_POINT_TIERS.find(
                        tier => codeChanges >= tier.minChanges,
                      )?.points ?? 0)
                    : 0;

                const isReleasePR = pr.title?.match(/ðŸ”–.*\d+\.\d+\.\d+/);

                if (isReleasePR) {
                  const { data: prDetails } = await github.rest.pulls.get({
                    owner,
                    repo,
                    pull_number: pr.number,
                  });

                  if (
                    prDetails.merged_by &&
                    stats.has(prDetails.merged_by.login)
                  ) {
                    const mergerStats = stats.get(prDetails.merged_by.login);
                    mergerStats.codeReviews.push({
                      pr: pr.number.toString(),
                      points: CONFIG.POINTS_PER_RELEASE_PR,
                      isReleaseMerger: true,
                    });
                    mergerStats.points += CONFIG.POINTS_PER_RELEASE_PR;
                  }
                  return;
                }

                const uniqueReviewers = new Set();
                reviews.data.forEach(review => {
                  if (
                    review.state === 'APPROVED' &&
                    stats.has(review.user?.login) &&
                    !uniqueReviewers.has(review.user?.login)
                  ) {
                    const reviewer = review.user.login;
                    uniqueReviewers.add(reviewer);
                    const userStats = stats.get(reviewer);

                    if (docsPoints > 0) {
                      userStats.docsReviews.push({
                        pr: pr.number.toString(),
                        points: docsPoints,
                      });
                      userStats.points += docsPoints;
                    }

                    if (codePoints > 0) {
                      userStats.codeReviews.push({
                        pr: pr.number.toString(),
                        points: codePoints,
                      });
                      userStats.points += codePoints;
                    }
                  }
                });
              });

              const issues = await github.paginate(github.rest.issues.listForRepo, {
                owner,
                repo,
                state: 'all',
                sort: 'updated',
                direction: 'desc',
                per_page: 100,
                since: since.toISOString(),
              });

              await withConcurrency(issues, 50, async issue => {
                const { data: events } =
                  await github.rest.issues.listEventsForTimeline({
                    owner,
                    repo,
                    issue_number: issue.number,
                  });

                events
                  .filter(event => {
                    const createdAt = new Date(event.created_at);
                    return (
                      createdAt.getTime() > since.getTime() &&
                      createdAt.getTime() <= until.getTime() &&
                      stats.has(event.actor?.login)
                    );
                  })
                  .forEach(event => {
                    if (
                      event.event === 'unlabeled' &&
                      event.label?.name.toLowerCase() === 'needs triage'
                    ) {
                      const remover = event.actor.login;
                      const userStats = stats.get(remover);
                      userStats.labelRemovals.push(issue.number.toString());
                      userStats.points += CONFIG.POINTS_PER_ISSUE_TRIAGE_ACTION;
                    }

                    if (
                      event.event === 'closed' &&
                      ['not_planned', 'duplicate'].includes(event.state_reason)
                    ) {
                      const closer = event.actor.login;
                      const userStats = stats.get(closer);
                      userStats.issueClosings.push(issue.number.toString());
                      userStats.points += CONFIG.POINTS_PER_ISSUE_CLOSING_ACTION;
                    }
                  });
              });

              printStats(
                'Code Review Statistics',
                userStats => userStats.codeReviews.length,
                (user, count) =>
                  `${user}: ${count} (PRs: ${stats
                    .get(user)
                    .codeReviews.map(review => {
                      if (review.isReleaseMerger) {
                        return `#${review.pr} (${review.points}pts - Release Merger)`;
                      }
                      return `#${review.pr} (${review.points}pts)`;
                    })
                    .join(', ')})`,
              );

              printStats(
                'Docs Review Statistics',
                userStats => userStats.docsReviews.length,
                (user, count) =>
                  `${user}: ${count} (PRs: ${stats
                    .get(user)
                    .docsReviews.map(review => `#${review.pr} (${review.points}pts)`)
                    .join(', ')})`,
              );

              printStats(
                '"Needs Triage" Label Removal Statistics',
                userStats => userStats.labelRemovals.length,
                (user, count) =>
                  `${user}: ${count} (Issues: ${stats
                    .get(user)
                    .labelRemovals.join(', ')})`,
              );

              printStats(
                'Issue Closing Statistics',
                userStats => userStats.issueClosings.length,
                (user, count) =>
                  `${user}: ${count} (Issues: ${stats
                    .get(user)
                    .issueClosings.join(', ')})`,
              );

              printStats(
                'Points Summary',
                userStats => userStats.points,
                (user, userPoints) => `${user}: ${userPoints}`,
              );

              const totalPoints = Array.from(stats.values()).reduce(
                (sum, userStats) => sum + userStats.points,
                0,
              );
              console.log(`\nTotal points earned: ${totalPoints}`);
            }

            await countContributorPoints();
